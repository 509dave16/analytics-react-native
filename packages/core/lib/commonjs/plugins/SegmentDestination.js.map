{"version":3,"sources":["SegmentDestination.ts"],"names":["MAX_EVENTS_PER_BATCH","MAX_PAYLOAD_SIZE_IN_KB","SEGMENT_DESTINATION_KEY","SegmentDestination","DestinationPlugin","PluginType","destination","events","length","Promise","resolve","chunkedEvents","analytics","getConfig","maxBatchSize","sentEvents","numFailedEvents","all","map","batch","config","concat","e","console","warn","queuePlugin","dequeue","debug","info","error","QueueFlushingPlugin","sendEvents","configure","add","DestinationMetadataEnrichment","execute","event","enrichedEvent","flush"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;AAEA,MAAMA,oBAAoB,GAAG,GAA7B;AACA,MAAMC,sBAAsB,GAAG,GAA/B;AACO,MAAMC,uBAAuB,GAAG,YAAhC;;;AAEA,MAAMC,kBAAN,SAAiCC,yBAAjC,CAAmD;AAAA;AAAA;;AAAA,kCACjDC,kBAAWC,WADsC;;AAAA,iCAGlDJ,uBAHkD;;AAAA,wCAKnC,MAAOK,MAAP,IAAiD;AAAA;;AACpE,UAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,eAAOC,OAAO,CAACC,OAAR,EAAP;AACD;;AAED,YAAMC,aAA+B,GAAG,iBACtCJ,MADsC,8CAEtC,KAAKK,SAFiC,oDAEtC,gBAAgBC,SAAhB,GAA4BC,YAFU,yEAEMd,oBAFN,EAGtCC,sBAHsC,CAAxC;AAMA,UAAIc,UAA0B,GAAG,EAAjC;AACA,UAAIC,eAAe,GAAG,CAAtB;AAEA,YAAMP,OAAO,CAACQ,GAAR,CACJN,aAAa,CAACO,GAAd,CAAkB,MAAOC,KAAP,IAAiC;AACjD,YAAI;AAAA;;AACF,gBAAM,uBAAa;AACjBC,YAAAA,MAAM,sBAAE,KAAKR,SAAP,qDAAE,iBAAgBC,SAAhB,EADS;AAEjBN,YAAAA,MAAM,EAAEY;AAFS,WAAb,CAAN;AAIAJ,UAAAA,UAAU,GAAGA,UAAU,CAACM,MAAX,CAAkBF,KAAlB,CAAb;AACD,SAND,CAME,OAAOG,CAAP,EAAU;AACVC,UAAAA,OAAO,CAACC,IAAR,CAAaF,CAAb;AACAN,UAAAA,eAAe,IAAIG,KAAK,CAACX,MAAzB;AACD,SATD,SASU;AACR,gBAAM,KAAKiB,WAAL,CAAiBC,OAAjB,CAAyBX,UAAzB,CAAN;AACD;AACF,OAbD,CADI,CAAN;;AAiBA,UAAIA,UAAU,CAACP,MAAf,EAAuB;AAAA;;AACrB,gCAAI,KAAKI,SAAT,6CAAI,iBAAgBC,SAAhB,GAA4Bc,KAAhC,EAAuC;AACrCJ,UAAAA,OAAO,CAACK,IAAR,CAAc,QAAOb,UAAU,CAACP,MAAO,SAAvC;AACD;AACF;;AAED,UAAIQ,eAAJ,EAAqB;AACnBO,QAAAA,OAAO,CAACM,KAAR,CAAe,kBAAiBb,eAAgB,UAAhD;AACD;;AAED,aAAOP,OAAO,CAACC,OAAR,EAAP;AACD,KA/CuD;;AAAA,yCAiDzB,IAAIoB,wCAAJ,CAAwB,KAAKC,UAA7B,CAjDyB;AAAA;;AAmDxDC,EAAAA,SAAS,CAACpB,SAAD,EAAiC;AACxC,UAAMoB,SAAN,CAAgBpB,SAAhB,EADwC,CAGxC;;AACA,SAAKqB,GAAL,CAAS,IAAIC,4DAAJ,CAAkChC,uBAAlC,CAAT;AACA,SAAK+B,GAAL,CAAS,KAAKR,WAAd;AACD;;AAEDU,EAAAA,OAAO,CAACC,KAAD,EAAgD;AACrD;AACA,UAAMC,aAAa,GAAG,MAAMF,OAAN,CAAcC,KAAd,CAAtB;AACA,WAAOC,aAAP;AACD;;AAEU,QAALC,KAAK,GAAG;AACZ,WAAO,KAAKb,WAAL,CAAiBa,KAAjB,EAAP;AACD;;AAnEuD","sourcesContent":["import { DestinationPlugin } from '../plugin';\nimport { PluginType, SegmentEvent } from '../types';\nimport { chunk } from '../util';\nimport { uploadEvents } from '../api';\nimport type { SegmentClient } from '../analytics';\nimport { DestinationMetadataEnrichment } from './DestinationMetadataEnrichment';\nimport { QueueFlushingPlugin } from './QueueFlushingPlugin';\n\nconst MAX_EVENTS_PER_BATCH = 100;\nconst MAX_PAYLOAD_SIZE_IN_KB = 500;\nexport const SEGMENT_DESTINATION_KEY = 'Segment.io';\n\nexport class SegmentDestination extends DestinationPlugin {\n  type = PluginType.destination;\n\n  key = SEGMENT_DESTINATION_KEY;\n\n  private sendEvents = async (events: SegmentEvent[]): Promise<void> => {\n    if (events.length === 0) {\n      return Promise.resolve();\n    }\n\n    const chunkedEvents: SegmentEvent[][] = chunk(\n      events,\n      this.analytics?.getConfig().maxBatchSize ?? MAX_EVENTS_PER_BATCH,\n      MAX_PAYLOAD_SIZE_IN_KB\n    );\n\n    let sentEvents: SegmentEvent[] = [];\n    let numFailedEvents = 0;\n\n    await Promise.all(\n      chunkedEvents.map(async (batch: SegmentEvent[]) => {\n        try {\n          await uploadEvents({\n            config: this.analytics?.getConfig()!,\n            events: batch,\n          });\n          sentEvents = sentEvents.concat(batch);\n        } catch (e) {\n          console.warn(e);\n          numFailedEvents += batch.length;\n        } finally {\n          await this.queuePlugin.dequeue(sentEvents);\n        }\n      })\n    );\n\n    if (sentEvents.length) {\n      if (this.analytics?.getConfig().debug) {\n        console.info(`Sent ${sentEvents.length} events`);\n      }\n    }\n\n    if (numFailedEvents) {\n      console.error(`Failed to send ${numFailedEvents} events.`);\n    }\n\n    return Promise.resolve();\n  };\n\n  private readonly queuePlugin = new QueueFlushingPlugin(this.sendEvents);\n\n  configure(analytics: SegmentClient): void {\n    super.configure(analytics);\n\n    // Enrich events with the Destination metadata\n    this.add(new DestinationMetadataEnrichment(SEGMENT_DESTINATION_KEY));\n    this.add(this.queuePlugin);\n  }\n\n  execute(event: SegmentEvent): SegmentEvent | undefined {\n    // Execute the internal timeline here, the queue plugin will pick up the event and add it to the queue automatically\n    const enrichedEvent = super.execute(event);\n    return enrichedEvent;\n  }\n\n  async flush() {\n    return this.queuePlugin.flush();\n  }\n}\n"]}