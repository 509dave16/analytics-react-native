{"version":3,"sources":["QueueFlushingPlugin.ts"],"names":["QueueFlushingPlugin","UtilityPlugin","constructor","onFlush","PluginType","after","configure","analytics","config","getConfig","defaultConfig","queueStore","events","persist","storeId","writeKey","persistor","storePersistor","unsubscribe","subscribe","length","flushAt","flush","execute","event","dispatch","state","getState","isPendingUpload","dequeue","eventsToRemove","Array","isArray","setToRemove","Set","filteredEvents","filter","e","has"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;AAEA;AACA;AACA;AACA;AACA;AACO,MAAMA,mBAAN,SAAkCC,qBAAlC,CAAgD;AACrD;;AAQA;AACF;AACA;AACEC,EAAAA,WAAW,CAACC,OAAD,EAAqD;AAC9D;;AAD8D,kCAVzDC,kBAAWC,KAU8C;;AAAA,6CARtC,KAQsC;;AAAA;;AAAA;;AAAA;;AAE9D,SAAKF,OAAL,GAAeA,OAAf;AACD;;AAEDG,EAAAA,SAAS,CAACC,SAAD,EAAiC;AAAA;;AACxC,UAAMD,SAAN,CAAgBC,SAAhB;AAEA,UAAMC,MAAM,2BAAGD,SAAH,aAAGA,SAAH,uBAAGA,SAAS,CAAEE,SAAX,EAAH,uEAA6BC,wBAAzC,CAHwC,CAKxC;;AACA,SAAKC,UAAL,GAAkB,oCAChB;AAAEC,MAAAA,MAAM,EAAE;AAAV,KADgB,EAEhB;AACEC,MAAAA,OAAO,EAAE;AACPC,QAAAA,OAAO,EAAG,GAAEN,MAAM,CAACO,QAAS,SADrB;AAEPC,QAAAA,SAAS,EAAER,MAAM,CAACS;AAFX;AADX,KAFgB,CAAlB,CANwC,CAgBxC;;AACA,8BAAKC,WAAL;AACA,SAAKA,WAAL,GAAmB,KAAKP,UAAL,CAAgBQ,SAAhB,CAA0B,QAAgB;AAAA,UAAf;AAAEP,QAAAA;AAAF,OAAe;;AAC3D,UAAIA,MAAM,CAACQ,MAAP,IAAiBZ,MAAM,CAACa,OAA5B,EAAsC;AACpC,aAAKC,KAAL;AACD;AACF,KAJkB,CAAnB;AAKD;;AAEDC,EAAAA,OAAO,CAACC,KAAD,EAAgD;AAAA;;AACrD,6BAAKb,UAAL,sEAAiBc,QAAjB,CAA2BC,KAAD,IAAW;AACnC,YAAMd,MAAM,GAAG,CAAC,GAAGc,KAAK,CAACd,MAAV,EAAkBY,KAAlB,CAAf;AACA,aAAO;AAAEZ,QAAAA;AAAF,OAAP;AACD,KAHD;AAIA,WAAOY,KAAP;AACD;AAED;AACF;AACA;;;AACa,QAALF,KAAK,GAAG;AAAA;;AACZ,UAAMV,MAAM,iDAAG,KAAKD,UAAR,sDAAG,kBAAiBgB,QAAjB,GAA4Bf,MAA/B,yEAAyC,EAArD;;AACA,QAAI,CAAC,KAAKgB,eAAV,EAA2B;AACzB,UAAI;AACF,aAAKA,eAAL,GAAuB,IAAvB;AACA,cAAM,KAAKzB,OAAL,CAAaS,MAAb,CAAN;AACD,OAHD,SAGU;AACR,aAAKgB,eAAL,GAAuB,KAAvB;AACD;AACF;AACF;AAED;AACF;AACA;AACA;;;AACEC,EAAAA,OAAO,CACLjB,MADK,EAE4C;AAAA;;AACjD,gCAAO,KAAKD,UAAZ,sDAAO,kBAAiBc,QAAjB,CAA2BC,KAAD,IAAW;AAC1C,YAAMI,cAAc,GAAGC,KAAK,CAACC,OAAN,CAAcpB,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAAxD;;AAEA,UAAIkB,cAAc,CAACV,MAAf,KAA0B,CAA1B,IAA+BM,KAAK,CAACd,MAAN,CAAaQ,MAAb,KAAwB,CAA3D,EAA8D;AAC5D,eAAOM,KAAP;AACD;;AAED,YAAMO,WAAW,GAAG,IAAIC,GAAJ,CAAQJ,cAAR,CAApB;AACA,YAAMK,cAAc,GAAGT,KAAK,CAACd,MAAN,CAAawB,MAAb,CAAqBC,CAAD,IAAO,CAACJ,WAAW,CAACK,GAAZ,CAAgBD,CAAhB,CAA5B,CAAvB;AACA,aAAO;AAAEzB,QAAAA,MAAM,EAAEuB;AAAV,OAAP;AACD,KAVM,CAAP;AAWD;;AAnFoD","sourcesContent":["import { createStore, Store, Unsubscribe } from '@segment/sovran-react-native';\nimport type { SegmentClient } from '../analytics';\nimport { defaultConfig } from '../constants';\nimport { UtilityPlugin } from '../plugin';\nimport { PluginType, type SegmentEvent } from '../types';\n\n/**\n * This plugin manages a queue where all events get added to after timeline processing.\n * It takes a onFlush callback to trigger any action particular to your destination sending events.\n * It can autotrigger a flush of the queue when it reaches the config flushAt limit.\n */\nexport class QueueFlushingPlugin extends UtilityPlugin {\n  // Gets executed last to keep the queue after all timeline processing is done\n  type = PluginType.after;\n\n  private isPendingUpload = false;\n  private queueStore: Store<{ events: SegmentEvent[] }> | undefined;\n  private unsubscribe: Unsubscribe | undefined;\n  private onFlush: (events: SegmentEvent[]) => Promise<void>;\n\n  /**\n   * @param onFlush callback to execute when the queue is flushed (either by reaching the limit or manually) e.g. code to upload events to your destination\n   */\n  constructor(onFlush: (events: SegmentEvent[]) => Promise<void>) {\n    super();\n    this.onFlush = onFlush;\n  }\n\n  configure(analytics: SegmentClient): void {\n    super.configure(analytics);\n\n    const config = analytics?.getConfig() ?? defaultConfig;\n\n    // Create its own storage per SegmentDestination instance to support multiple instances\n    this.queueStore = createStore(\n      { events: [] as SegmentEvent[] },\n      {\n        persist: {\n          storeId: `${config.writeKey}-events`,\n          persistor: config.storePersistor,\n        },\n      }\n    );\n\n    // Setup subscribers to flush the events\n    this.unsubscribe?.();\n    this.unsubscribe = this.queueStore.subscribe(({ events }) => {\n      if (events.length >= config.flushAt!) {\n        this.flush();\n      }\n    });\n  }\n\n  execute(event: SegmentEvent): SegmentEvent | undefined {\n    this.queueStore?.dispatch((state) => {\n      const events = [...state.events, event];\n      return { events };\n    });\n    return event;\n  }\n\n  /**\n   * Calls the onFlush callback with the events in the queue\n   */\n  async flush() {\n    const events = this.queueStore?.getState().events ?? [];\n    if (!this.isPendingUpload) {\n      try {\n        this.isPendingUpload = true;\n        await this.onFlush(events);\n      } finally {\n        this.isPendingUpload = false;\n      }\n    }\n  }\n\n  /**\n   * Removes one or multiple events from the queue\n   * @param events events to remove\n   */\n  dequeue(\n    events: SegmentEvent | SegmentEvent[]\n  ): Promise<{ events: SegmentEvent[] }> | undefined {\n    return this.queueStore?.dispatch((state) => {\n      const eventsToRemove = Array.isArray(events) ? events : [events];\n\n      if (eventsToRemove.length === 0 || state.events.length === 0) {\n        return state;\n      }\n\n      const setToRemove = new Set(eventsToRemove);\n      const filteredEvents = state.events.filter((e) => !setToRemove.has(e));\n      return { events: filteredEvents };\n    });\n  }\n}\n"]}