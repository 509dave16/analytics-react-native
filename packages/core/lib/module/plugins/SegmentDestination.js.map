{"version":3,"sources":["SegmentDestination.ts"],"names":["DestinationPlugin","PluginType","chunk","uploadEvents","DestinationMetadataEnrichment","QueueFlushingPlugin","MAX_EVENTS_PER_BATCH","MAX_PAYLOAD_SIZE_IN_KB","SEGMENT_DESTINATION_KEY","SegmentDestination","destination","events","length","Promise","resolve","chunkedEvents","analytics","getConfig","maxBatchSize","sentEvents","numFailedEvents","all","map","batch","config","concat","e","console","warn","queuePlugin","dequeue","debug","info","error","sendEvents","configure","add","execute","event","enrichedEvent","flush"],"mappings":";;AAAA,SAASA,iBAAT,QAAkC,WAAlC;AACA,SAASC,UAAT,QAAyC,UAAzC;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,YAAT,QAA6B,QAA7B;AAEA,SAASC,6BAAT,QAA8C,iCAA9C;AACA,SAASC,mBAAT,QAAoC,uBAApC;AAEA,MAAMC,oBAAoB,GAAG,GAA7B;AACA,MAAMC,sBAAsB,GAAG,GAA/B;AACA,OAAO,MAAMC,uBAAuB,GAAG,YAAhC;AAEP,OAAO,MAAMC,kBAAN,SAAiCT,iBAAjC,CAAmD;AAAA;AAAA;;AAAA,kCACjDC,UAAU,CAACS,WADsC;;AAAA,iCAGlDF,uBAHkD;;AAAA,wCAKnC,MAAOG,MAAP,IAAiD;AAAA;;AACpE,UAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,eAAOC,OAAO,CAACC,OAAR,EAAP;AACD;;AAED,YAAMC,aAA+B,GAAGb,KAAK,CAC3CS,MAD2C,8CAE3C,KAAKK,SAFsC,oDAE3C,gBAAgBC,SAAhB,GAA4BC,YAFe,yEAECZ,oBAFD,EAG3CC,sBAH2C,CAA7C;AAMA,UAAIY,UAA0B,GAAG,EAAjC;AACA,UAAIC,eAAe,GAAG,CAAtB;AAEA,YAAMP,OAAO,CAACQ,GAAR,CACJN,aAAa,CAACO,GAAd,CAAkB,MAAOC,KAAP,IAAiC;AACjD,YAAI;AAAA;;AACF,gBAAMpB,YAAY,CAAC;AACjBqB,YAAAA,MAAM,sBAAE,KAAKR,SAAP,qDAAE,iBAAgBC,SAAhB,EADS;AAEjBN,YAAAA,MAAM,EAAEY;AAFS,WAAD,CAAlB;AAIAJ,UAAAA,UAAU,GAAGA,UAAU,CAACM,MAAX,CAAkBF,KAAlB,CAAb;AACD,SAND,CAME,OAAOG,CAAP,EAAU;AACVC,UAAAA,OAAO,CAACC,IAAR,CAAaF,CAAb;AACAN,UAAAA,eAAe,IAAIG,KAAK,CAACX,MAAzB;AACD,SATD,SASU;AACR,gBAAM,KAAKiB,WAAL,CAAiBC,OAAjB,CAAyBX,UAAzB,CAAN;AACD;AACF,OAbD,CADI,CAAN;;AAiBA,UAAIA,UAAU,CAACP,MAAf,EAAuB;AAAA;;AACrB,gCAAI,KAAKI,SAAT,6CAAI,iBAAgBC,SAAhB,GAA4Bc,KAAhC,EAAuC;AACrCJ,UAAAA,OAAO,CAACK,IAAR,CAAc,QAAOb,UAAU,CAACP,MAAO,SAAvC;AACD;AACF;;AAED,UAAIQ,eAAJ,EAAqB;AACnBO,QAAAA,OAAO,CAACM,KAAR,CAAe,kBAAiBb,eAAgB,UAAhD;AACD;;AAED,aAAOP,OAAO,CAACC,OAAR,EAAP;AACD,KA/CuD;;AAAA,yCAiDzB,IAAIT,mBAAJ,CAAwB,KAAK6B,UAA7B,CAjDyB;AAAA;;AAmDxDC,EAAAA,SAAS,CAACnB,SAAD,EAAiC;AACxC,UAAMmB,SAAN,CAAgBnB,SAAhB,EADwC,CAGxC;;AACA,SAAKoB,GAAL,CAAS,IAAIhC,6BAAJ,CAAkCI,uBAAlC,CAAT;AACA,SAAK4B,GAAL,CAAS,KAAKP,WAAd;AACD;;AAEDQ,EAAAA,OAAO,CAACC,KAAD,EAAgD;AACrD;AACA,UAAMC,aAAa,GAAG,MAAMF,OAAN,CAAcC,KAAd,CAAtB;AACA,WAAOC,aAAP;AACD;;AAEU,QAALC,KAAK,GAAG;AACZ,WAAO,KAAKX,WAAL,CAAiBW,KAAjB,EAAP;AACD;;AAnEuD","sourcesContent":["import { DestinationPlugin } from '../plugin';\nimport { PluginType, SegmentEvent } from '../types';\nimport { chunk } from '../util';\nimport { uploadEvents } from '../api';\nimport type { SegmentClient } from '../analytics';\nimport { DestinationMetadataEnrichment } from './DestinationMetadataEnrichment';\nimport { QueueFlushingPlugin } from './QueueFlushingPlugin';\n\nconst MAX_EVENTS_PER_BATCH = 100;\nconst MAX_PAYLOAD_SIZE_IN_KB = 500;\nexport const SEGMENT_DESTINATION_KEY = 'Segment.io';\n\nexport class SegmentDestination extends DestinationPlugin {\n  type = PluginType.destination;\n\n  key = SEGMENT_DESTINATION_KEY;\n\n  private sendEvents = async (events: SegmentEvent[]): Promise<void> => {\n    if (events.length === 0) {\n      return Promise.resolve();\n    }\n\n    const chunkedEvents: SegmentEvent[][] = chunk(\n      events,\n      this.analytics?.getConfig().maxBatchSize ?? MAX_EVENTS_PER_BATCH,\n      MAX_PAYLOAD_SIZE_IN_KB\n    );\n\n    let sentEvents: SegmentEvent[] = [];\n    let numFailedEvents = 0;\n\n    await Promise.all(\n      chunkedEvents.map(async (batch: SegmentEvent[]) => {\n        try {\n          await uploadEvents({\n            config: this.analytics?.getConfig()!,\n            events: batch,\n          });\n          sentEvents = sentEvents.concat(batch);\n        } catch (e) {\n          console.warn(e);\n          numFailedEvents += batch.length;\n        } finally {\n          await this.queuePlugin.dequeue(sentEvents);\n        }\n      })\n    );\n\n    if (sentEvents.length) {\n      if (this.analytics?.getConfig().debug) {\n        console.info(`Sent ${sentEvents.length} events`);\n      }\n    }\n\n    if (numFailedEvents) {\n      console.error(`Failed to send ${numFailedEvents} events.`);\n    }\n\n    return Promise.resolve();\n  };\n\n  private readonly queuePlugin = new QueueFlushingPlugin(this.sendEvents);\n\n  configure(analytics: SegmentClient): void {\n    super.configure(analytics);\n\n    // Enrich events with the Destination metadata\n    this.add(new DestinationMetadataEnrichment(SEGMENT_DESTINATION_KEY));\n    this.add(this.queuePlugin);\n  }\n\n  execute(event: SegmentEvent): SegmentEvent | undefined {\n    // Execute the internal timeline here, the queue plugin will pick up the event and add it to the queue automatically\n    const enrichedEvent = super.execute(event);\n    return enrichedEvent;\n  }\n\n  async flush() {\n    return this.queuePlugin.flush();\n  }\n}\n"]}