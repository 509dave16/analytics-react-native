{"version":3,"sources":["QueueFlushingPlugin.ts"],"names":["createStore","defaultConfig","UtilityPlugin","PluginType","QueueFlushingPlugin","constructor","onFlush","after","configure","analytics","config","getConfig","queueStore","events","persist","storeId","writeKey","persistor","storePersistor","unsubscribe","subscribe","length","flushAt","flush","execute","event","dispatch","state","getState","isPendingUpload","dequeue","eventsToRemove","Array","isArray","console","log","setToRemove","Set","map","messageId","filter","filteredEvents","e","has"],"mappings":"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","sourcesContent":["import { createStore, Store, Unsubscribe } from '@segment/sovran-react-native';\nimport type { SegmentClient } from '../analytics';\nimport { defaultConfig } from '../constants';\nimport { UtilityPlugin } from '../plugin';\nimport { PluginType, type SegmentEvent } from '../types';\n\n/**\n * This plugin manages a queue where all events get added to after timeline processing.\n * It takes a onFlush callback to trigger any action particular to your destination sending events.\n * It can autotrigger a flush of the queue when it reaches the config flushAt limit.\n */\nexport class QueueFlushingPlugin extends UtilityPlugin {\n  // Gets executed last to keep the queue after all timeline processing is done\n  type = PluginType.after;\n\n  private isPendingUpload = false;\n  private queueStore: Store<{ events: SegmentEvent[] }> | undefined;\n  private unsubscribe: Unsubscribe | undefined;\n  private onFlush: (events: SegmentEvent[]) => Promise<void>;\n\n  /**\n   * @param onFlush callback to execute when the queue is flushed (either by reaching the limit or manually) e.g. code to upload events to your destination\n   */\n  constructor(onFlush: (events: SegmentEvent[]) => Promise<void>) {\n    super();\n    this.onFlush = onFlush;\n  }\n\n  configure(analytics: SegmentClient): void {\n    super.configure(analytics);\n\n    const config = analytics?.getConfig() ?? defaultConfig;\n\n    // Create its own storage per SegmentDestination instance to support multiple instances\n    this.queueStore = createStore(\n      { events: [] as SegmentEvent[] },\n      {\n        persist: {\n          storeId: `${config.writeKey}-events`,\n          persistor: config.storePersistor,\n        },\n      }\n    );\n\n    // Setup subscribers to flush the events\n    this.unsubscribe?.();\n    this.unsubscribe = this.queueStore.subscribe(({ events }) => {\n      if (events.length >= config.flushAt!) {\n        this.flush();\n      }\n    });\n  }\n\n  execute(event: SegmentEvent): SegmentEvent | undefined {\n    this.queueStore?.dispatch((state) => {\n      const events = [...state.events, event];\n      return { events };\n    });\n    return event;\n  }\n\n  /**\n   * Calls the onFlush callback with the events in the queue\n   */\n  async flush() {\n    const events = this.queueStore?.getState().events ?? [];\n    if (!this.isPendingUpload) {\n      try {\n        this.isPendingUpload = true;\n        await this.onFlush(events);\n      } finally {\n        this.isPendingUpload = false;\n      }\n    }\n  }\n\n  /**\n   * Removes one or multiple events from the queue\n   * @param events events to remove\n   */\n  dequeue(\n    events: SegmentEvent | SegmentEvent[]\n  ): Promise<{ events: SegmentEvent[] }> | undefined {\n    return this.queueStore?.dispatch((state) => {\n      const eventsToRemove = Array.isArray(events) ? events : [events];\n\n      if (eventsToRemove.length === 0 || state.events.length === 0) {\n        console.log('ARN - events to remove', eventsToRemove.length);\n        return state;\n      }\n\n      const setToRemove = new Set(\n        eventsToRemove\n          .map((event) => event.messageId)\n          .filter((messageId) => messageId)\n      );\n      const filteredEvents = state.events.filter(\n        (e) => !setToRemove.has(e.messageId)\n      );\n      return { events: filteredEvents };\n    });\n  }\n}\n"]}