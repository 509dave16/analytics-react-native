{"version":3,"sources":["util.ts"],"names":["sizeOf","obj","size","encodeURI","JSON","stringify","split","length","chunk","array","count","maxKB","currentChunk","rollingKBSize","result","reduce","chunks","item","index","undefined","push","getAllPlugins","timeline","allPlugins","Object","values","plugins","prev","curr","concat","getPluginsWithFlush","eventPlugins","filter","f","flush","getPluginsWithReset","reset"],"mappings":"AAGA,MAAMA,MAAM,GAAIC,GAAD,IAA0B;AACvC,QAAMC,IAAI,GAAGC,SAAS,CAACC,IAAI,CAACC,SAAL,CAAeJ,GAAf,CAAD,CAAT,CAA+BK,KAA/B,CAAqC,OAArC,EAA8CC,MAA9C,GAAuD,CAApE;AACA,SAAOL,IAAI,GAAG,IAAd;AACD,CAHD;;AAKA,OAAO,MAAMM,KAAK,GAAG,CAACC,KAAD,EAAeC,KAAf,EAA8BC,KAA9B,KAAiD;AACpE,MAAI,CAACF,KAAK,CAACF,MAAP,IAAiB,CAACG,KAAtB,EAA6B;AAC3B,WAAO,EAAP;AACD;;AAED,MAAIE,YAAY,GAAG,CAAnB;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,QAAMC,MAAa,GAAGL,KAAK,CAACM,MAAN,CACpB,CAACC,MAAD,EAAkBC,IAAlB,EAA6BC,KAA7B,KAA+C;AAC7C,QAAIP,KAAK,KAAKQ,SAAd,EAAyB;AACvBN,MAAAA,aAAa,IAAIb,MAAM,CAACiB,IAAD,CAAvB,CADuB,CAEvB;;AACA,UAAIJ,aAAa,IAAIF,KAArB,EAA4B;AAC1BK,QAAAA,MAAM,CAAC,EAAEJ,YAAH,CAAN,GAAyB,CAACK,IAAD,CAAzB;AACA,eAAOD,MAAP;AACD;AACF;;AAED,QAAIE,KAAK,KAAK,CAAV,IAAeA,KAAK,GAAGR,KAAR,KAAkB,CAArC,EAAwC;AACtCM,MAAAA,MAAM,CAAC,EAAEJ,YAAH,CAAN,GAAyB,CAACK,IAAD,CAAzB;AACD,KAFD,MAEO;AACL,UAAID,MAAM,CAACJ,YAAD,CAAN,KAAyBO,SAA7B,EAAwC;AACtCH,QAAAA,MAAM,CAACJ,YAAD,CAAN,GAAuB,EAAvB;AACD;;AACDI,MAAAA,MAAM,CAACJ,YAAD,CAAN,CAAqBQ,IAArB,CAA0BH,IAA1B;AACD;;AAED,WAAOD,MAAP;AACD,GArBmB,EAsBpB,EAtBoB,CAAtB;AAyBA,SAAOF,MAAP;AACD,CAjCM;AAmCP,OAAO,MAAMO,aAAa,GAAIC,QAAD,IAAwB;AACnD,QAAMC,UAAU,GAAGC,MAAM,CAACC,MAAP,CAAcH,QAAQ,CAACI,OAAvB,CAAnB;;AACA,MAAIH,UAAU,CAAChB,MAAf,EAAuB;AACrB,WAAOgB,UAAU,CAACR,MAAX,CAAkB;AAAA,UAACY,IAAD,uEAAQ,EAAR;AAAA,UAAYC,IAAZ,uEAAmB,EAAnB;AAAA,aAA0BD,IAAI,CAACE,MAAL,CAAYD,IAAZ,CAA1B;AAAA,KAAlB,CAAP;AACD;;AACD,SAAO,EAAP;AACD,CANM;AAQP,OAAO,MAAME,mBAAmB,GAAIR,QAAD,IAAwB;AACzD,MAAI,CAACA,QAAL,EAAe;AACb,WAAO,EAAP;AACD;;AAED,QAAMC,UAAU,GAAGF,aAAa,CAACC,QAAD,CAAhC,CALyD,CAOzD;;AACA,QAAMS,YAAY,GAAGR,UAAH,aAAGA,UAAH,uBAAGA,UAAU,CAAES,MAAZ,CAClBC,CAAD,IAAQA,CAAD,CAAmBC,KADP,CAArB;AAIA,SAAOH,YAAP;AACD,CAbM;AAeP,OAAO,MAAMI,mBAAmB,GAAIb,QAAD,IAAwB;AACzD,MAAI,CAACA,QAAL,EAAe;AACb,WAAO,EAAP;AACD;;AAED,QAAMC,UAAU,GAAGF,aAAa,CAACC,QAAD,CAAhC,CALyD,CAOzD;;AACA,QAAMS,YAAY,GAAGR,UAAH,aAAGA,UAAH,uBAAGA,UAAU,CAAES,MAAZ,CAClBC,CAAD,IAAQA,CAAD,CAAmBG,KADP,CAArB;AAIA,SAAOL,YAAP;AACD,CAbM","sourcesContent":["import type { EventPlugin } from './plugin';\nimport type { Timeline } from './timeline';\n\nconst sizeOf = (obj: unknown): number => {\n  const size = encodeURI(JSON.stringify(obj)).split(/%..|./).length - 1;\n  return size / 1024;\n};\n\nexport const chunk = (array: any[], count: number, maxKB?: number) => {\n  if (!array.length || !count) {\n    return [];\n  }\n\n  let currentChunk = 0;\n  let rollingKBSize = 0;\n  const result: any[] = array.reduce(\n    (chunks: any[][], item: any, index: number) => {\n      if (maxKB !== undefined) {\n        rollingKBSize += sizeOf(item);\n        // If we overflow chunk until the previous index, else keep going\n        if (rollingKBSize >= maxKB) {\n          chunks[++currentChunk] = [item];\n          return chunks;\n        }\n      }\n\n      if (index !== 0 && index % count === 0) {\n        chunks[++currentChunk] = [item];\n      } else {\n        if (chunks[currentChunk] === undefined) {\n          chunks[currentChunk] = [];\n        }\n        chunks[currentChunk].push(item);\n      }\n\n      return chunks;\n    },\n    []\n  );\n\n  return result;\n};\n\nexport const getAllPlugins = (timeline: Timeline) => {\n  const allPlugins = Object.values(timeline.plugins);\n  if (allPlugins.length) {\n    return allPlugins.reduce((prev = [], curr = []) => prev.concat(curr));\n  }\n  return [];\n};\n\nexport const getPluginsWithFlush = (timeline: Timeline) => {\n  if (!timeline) {\n    return [];\n  }\n\n  const allPlugins = getAllPlugins(timeline);\n\n  // checking for the existence of .flush()\n  const eventPlugins = allPlugins?.filter(\n    (f) => (f as EventPlugin).flush\n  ) as EventPlugin[];\n\n  return eventPlugins;\n};\n\nexport const getPluginsWithReset = (timeline: Timeline) => {\n  if (!timeline) {\n    return [];\n  }\n\n  const allPlugins = getAllPlugins(timeline);\n\n  // checking for the existence of .reset()\n  const eventPlugins = allPlugins?.filter(\n    (f) => (f as EventPlugin).reset\n  ) as EventPlugin[];\n\n  return eventPlugins;\n};\n"]}